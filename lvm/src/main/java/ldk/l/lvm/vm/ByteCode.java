package ldk.l.lvm.vm;

public class ByteCode {
    public static final long ZERO_MARK = 0b01L;
    public static final long CARRY_MARK = 0b10L;
    public static final long UNSIGNED_MARK = 0b100L;
    public static final byte PC_REGISTER = 39;
    public static final byte SP_REGISTER = 38;
    public static final byte BP_REGISTER = 37;

    public static final byte NOP = 0x00;
    public static final byte PUSH_1 = 0x01;
    public static final byte PUSH_2 = 0x02;
    public static final byte PUSH_4 = 0x03;
    public static final byte PUSH_8 = 0x04;
    public static final byte POP_1 = 0x05;
    public static final byte POP_2 = 0x06;
    public static final byte POP_4 = 0x07;
    public static final byte POP_8 = 0x08;
    public static final byte LOAD_1 = 0x09;
    public static final byte LOAD_2 = 0x0a;
    public static final byte LOAD_4 = 0x0b;
    public static final byte LOAD_8 = 0x0c;
    public static final byte STORE_1 = 0x0d;
    public static final byte STORE_2 = 0x0e;
    public static final byte STORE_4 = 0x0f;
    public static final byte STORE_8 = 0x10;
    public static final byte CMP = 0x11;
    public static final byte ATOMIC_CMP = 0x12;
    public static final byte MOV_E = 0x13;
    public static final byte MOV_NE = 0x14;
    public static final byte MOV_L = 0x15;
    public static final byte MOV_LE = 0x16;
    public static final byte MOV_G = 0x17;
    public static final byte MOV_GE = 0x18;
    public static final byte MOV_UL = 0x19;
    public static final byte MOV_ULE = 0x1a;
    public static final byte MOV_UG = 0x1b;
    public static final byte MOV_UGE = 0x1c;
    public static final byte MOV = 0x1d;
    public static final byte MOV_IMMEDIATE1 = 0x1e;
    public static final byte MOV_IMMEDIATE2 = 0x1f;
    public static final byte MOV_IMMEDIATE4 = 0x20;
    public static final byte MOV_IMMEDIATE8 = 0x21;
    public static final byte JUMP = 0x22;
    public static final byte JUMP_IMMEDIATE = 0x23;
    public static final byte JE = 0x24;
    public static final byte JNE = 0x25;
    public static final byte JL = 0x26;
    public static final byte JLE = 0x27;
    public static final byte JG = 0x28;
    public static final byte JGE = 0x29;
    public static final byte JUL = 0x2a;
    public static final byte JULE = 0x2b;
    public static final byte JUG = 0x2c;
    public static final byte JUGE = 0x2d;
    public static final byte MALLOC = 0x2e;
    public static final byte FREE = 0x2f;
    public static final byte REALLOC = 0x30;
    public static final byte ADD = 0x31;
    public static final byte SUB = 0x32;
    public static final byte MUL = 0x33;
    public static final byte DIV = 0x34;
    public static final byte MOD = 0x35;
    public static final byte AND = 0x36;
    public static final byte OR = 0x37;
    public static final byte XOR = 0x38;
    public static final byte NOT = 0x39;
    public static final byte NEG = 0x3a;
    public static final byte SHL = 0x3b;
    public static final byte SHR = 0x3c;
    public static final byte USHR = 0x3d;
    public static final byte INC = 0x3e;
    public static final byte DEC = 0x3f;
    public static final byte ADD_DOUBLE = 0x40;
    public static final byte SUB_DOUBLE = 0x41;
    public static final byte MUL_DOUBLE = 0x42;
    public static final byte DIV_DOUBLE = 0x43;
    public static final byte MOD_DOUBLE = 0x44;
    public static final byte ADD_FLOAT = 0x45;
    public static final byte SUB_FLOAT = 0x46;
    public static final byte MUL_FLOAT = 0x47;
    public static final byte DIV_FLOAT = 0x48;
    public static final byte MOD_FLOAT = 0x49;
    public static final byte ATOMIC_ADD = 0x4a;
    public static final byte ATOMIC_SUB = 0x4b;
    public static final byte ATOMIC_MUL = 0x4c;
    public static final byte ATOMIC_DIV = 0x4d;
    public static final byte ATOMIC_MOD = 0x4e;
    public static final byte ATOMIC_AND = 0x4f;
    public static final byte ATOMIC_OR = 0x50;
    public static final byte ATOMIC_XOR = 0x51;
    public static final byte ATOMIC_NOT = 0x52;
    public static final byte ATOMIC_NEG = 0x53;
    public static final byte ATOMIC_SHL = 0x54;
    public static final byte ATOMIC_SHR = 0x55;
    public static final byte ATOMIC_USHR = 0x56;
    public static final byte ATOMIC_INC = 0x57;
    public static final byte ATOMIC_DEC = 0x58;
    public static final byte ATOMIC_ADD_DOUBLE = 0x59;
    public static final byte ATOMIC_SUB_DOUBLE = 0x5a;
    public static final byte ATOMIC_MUL_DOUBLE = 0x5b;
    public static final byte ATOMIC_DIV_DOUBLE = 0x5c;
    public static final byte ATOMIC_MOD_DOUBLE = 0x5d;
    public static final byte ATOMIC_ADD_FLOAT = 0x5e;
    public static final byte ATOMIC_SUB_FLOAT = 0x5f;
    public static final byte ATOMIC_MUL_FLOAT = 0x60;
    public static final byte ATOMIC_DIV_FLOAT = 0x61;
    public static final byte ATOMIC_MOD_FLOAT = 0x62;
    public static final byte CAS = 0x63;
    public static final byte INVOKE = 0x64;
    public static final byte INVOKE_IMMEDIATE = 0x65;
    public static final byte RETURN = 0x66;
    public static final byte GET_RESULT = 0x67;
    public static final byte SET_RESULT = 0x68;
    public static final byte LONG_TO_BYTE = 0x69;
    public static final byte LONG_TO_SHORT = 0x6a;
    public static final byte LONG_TO_INT = 0x6b;
    public static final byte BYTE_TO_LONG = 0x6c;
    public static final byte SHORT_TO_LONG = 0x6d;
    public static final byte INT_TO_LONG = 0x6e;
    public static final byte LONG_TO_DOUBLE = 0x6f;
    public static final byte DOUBLE_TO_LONG = 0x70;
    public static final byte DOUBLE_TO_FLOAT = 0x71;
    public static final byte FLOAT_TO_DOUBLE = 0x72;
    public static final byte OPEN = 0x73;
    public static final byte CLOSE = 0x74;
    public static final byte READ = 0x75;
    public static final byte WRITE = 0x76;
    public static final byte CREATE_FRAME = 0x77;
    public static final byte DESTROY_FRAME = 0x78;
    public static final byte EXIT = 0x79;
    public static final byte EXIT_IMMEDIATE = 0x7a;

    public static String getInstructionName(byte code) {
        return switch (code) {
            case NOP -> "nop";
            case PUSH_1 -> "push_1";
            case PUSH_2 -> "push_2";
            case PUSH_4 -> "push_4";
            case PUSH_8 -> "push_8";
            case POP_1 -> "pop_1";
            case POP_2 -> "pop_2";
            case POP_4 -> "pop_4";
            case POP_8 -> "pop_8";
            case LOAD_1 -> "load_1";
            case LOAD_2 -> "load_2";
            case LOAD_4 -> "load_4";
            case LOAD_8 -> "load_8";
            case STORE_1 -> "store_1";
            case STORE_2 -> "store_2";
            case STORE_4 -> "store_4";
            case STORE_8 -> "store_8";
            case CMP -> "cmp";
            case ATOMIC_CMP -> "atomic_cmp";
            case MOV_E -> "mov_e";
            case MOV_NE -> "mov_ne";
            case MOV_L -> "mov_l";
            case MOV_LE -> "mov_le";
            case MOV_G -> "mov_g";
            case MOV_GE -> "mov_ge";
            case MOV_UL -> "mov_ul";
            case MOV_ULE -> "mov_ule";
            case MOV_UG -> "mov_ug";
            case MOV_UGE -> "mov_uge";
            case MOV -> "mov";
            case MOV_IMMEDIATE1 -> "mov_immediate1";
            case MOV_IMMEDIATE2 -> "mov_immediate2";
            case MOV_IMMEDIATE4 -> "mov_immediate4";
            case MOV_IMMEDIATE8 -> "mov_immediate8";
            case JUMP -> "jump";
            case JUMP_IMMEDIATE -> "jump_immediate";
            case JE -> "je";
            case JNE -> "jne";
            case JL -> "jl";
            case JLE -> "jle";
            case JG -> "jg";
            case JGE -> "jge";
            case JUL -> "jul";
            case JULE -> "jule";
            case JUG -> "jug";
            case JUGE -> "juge";
            case MALLOC -> "malloc";
            case FREE -> "free";
            case REALLOC -> "realloc";
            case ADD -> "add";
            case SUB -> "sub";
            case MUL -> "mul";
            case DIV -> "div";
            case MOD -> "mod";
            case AND -> "and";
            case OR -> "or";
            case XOR -> "xor";
            case NOT -> "not";
            case NEG -> "neg";
            case SHL -> "shl";
            case SHR -> "shr";
            case USHR -> "ushr";
            case INC -> "inc";
            case DEC -> "dec";
            case ADD_DOUBLE -> "add_double";
            case SUB_DOUBLE -> "sub_double";
            case MUL_DOUBLE -> "mul_double";
            case DIV_DOUBLE -> "div_double";
            case MOD_DOUBLE -> "mod_double";
            case ADD_FLOAT -> "add_float";
            case SUB_FLOAT -> "sub_float";
            case MUL_FLOAT -> "mul_float";
            case DIV_FLOAT -> "div_float";
            case MOD_FLOAT -> "mod_float";
            case ATOMIC_ADD -> "atomic_add";
            case ATOMIC_SUB -> "atomic_sub";
            case ATOMIC_MUL -> "atomic_mul";
            case ATOMIC_DIV -> "atomic_div";
            case ATOMIC_MOD -> "atomic_mod";
            case ATOMIC_AND -> "atomic_and";
            case ATOMIC_OR -> "atomic_or";
            case ATOMIC_XOR -> "atomic_xor";
            case ATOMIC_NOT -> "atomic_not";
            case ATOMIC_NEG -> "atomic_neg";
            case ATOMIC_SHL -> "atomic_shl";
            case ATOMIC_SHR -> "atomic_shr";
            case ATOMIC_USHR -> "atomic_ushr";
            case ATOMIC_INC -> "atomic_inc";
            case ATOMIC_DEC -> "atomic_dec";
            case ATOMIC_ADD_DOUBLE -> "atomic_add_double";
            case ATOMIC_SUB_DOUBLE -> "atomic_sub_double";
            case ATOMIC_MUL_DOUBLE -> "atomic_mul_double";
            case ATOMIC_DIV_DOUBLE -> "atomic_div_double";
            case ATOMIC_MOD_DOUBLE -> "atomic_mod_double";
            case ATOMIC_ADD_FLOAT -> "atomic_add_float";
            case ATOMIC_SUB_FLOAT -> "atomic_sub_float";
            case ATOMIC_MUL_FLOAT -> "atomic_mul_float";
            case ATOMIC_DIV_FLOAT -> "atomic_div_float";
            case ATOMIC_MOD_FLOAT -> "atomic_mod_float";
            case CAS -> "cas";
            case INVOKE -> "invoke";
            case INVOKE_IMMEDIATE -> "invoke_immediate";
            case RETURN -> "return";
            case GET_RESULT -> "get_result";
            case SET_RESULT -> "set_result";
            case LONG_TO_BYTE -> "long_to_byte";
            case LONG_TO_SHORT -> "long_to_short";
            case LONG_TO_INT -> "long_to_int";
            case BYTE_TO_LONG -> "byte_to_long";
            case SHORT_TO_LONG -> "short_to_long";
            case INT_TO_LONG -> "int_to_long";
            case LONG_TO_DOUBLE -> "long_to_double";
            case DOUBLE_TO_LONG -> "double_to_long";
            case DOUBLE_TO_FLOAT -> "double_to_float";
            case FLOAT_TO_DOUBLE -> "float_to_double";
            case OPEN -> "open";
            case CLOSE -> "close";
            case READ -> "read";
            case WRITE -> "write";
            case CREATE_FRAME -> "create_frame";
            case DESTROY_FRAME -> "destroy_frame";
            case EXIT -> "exit";
            case EXIT_IMMEDIATE -> "exit_immediate";
            default -> throw new IllegalArgumentException("Unknown instruction code: " + code);
        };
    }

    public static byte parseInstruction(String code) {
        return switch (code.toLowerCase()) {
            case "nop" -> NOP;
            case "push_1" -> PUSH_1;
            case "push_2" -> PUSH_2;
            case "push_4" -> PUSH_4;
            case "push_8" -> PUSH_8;
            case "pop_1" -> POP_1;
            case "pop_2" -> POP_2;
            case "pop_4" -> POP_4;
            case "pop_8" -> POP_8;
            case "load_1" -> LOAD_1;
            case "load_2" -> LOAD_2;
            case "load_4" -> LOAD_4;
            case "load_8" -> LOAD_8;
            case "store_1" -> STORE_1;
            case "store_2" -> STORE_2;
            case "store_4" -> STORE_4;
            case "store_8" -> STORE_8;
            case "cmp" -> CMP;
            case "atomic_cmp" -> ATOMIC_CMP;
            case "mov_e" -> MOV_E;
            case "mov_ne" -> MOV_NE;
            case "mov_l" -> MOV_L;
            case "mov_le" -> MOV_LE;
            case "mov_g" -> MOV_G;
            case "mov_ge" -> MOV_GE;
            case "mov_ul" -> MOV_UL;
            case "mov_ule" -> MOV_ULE;
            case "mov_ug" -> MOV_UG;
            case "mov_uge" -> MOV_UGE;
            case "mov" -> MOV;
            case "mov_immediate1" -> MOV_IMMEDIATE1;
            case "mov_immediate2" -> MOV_IMMEDIATE2;
            case "mov_immediate4" -> MOV_IMMEDIATE4;
            case "mov_immediate8" -> MOV_IMMEDIATE8;
            case "jump" -> JUMP;
            case "jump_immediate" -> JUMP_IMMEDIATE;
            case "je" -> JE;
            case "jne" -> JNE;
            case "jl" -> JL;
            case "jle" -> JLE;
            case "jg" -> JG;
            case "jge" -> JGE;
            case "jul" -> JUL;
            case "jule" -> JULE;
            case "jug" -> JUG;
            case "juge" -> JUGE;
            case "malloc" -> MALLOC;
            case "free" -> FREE;
            case "realloc" -> REALLOC;
            case "add" -> ADD;
            case "sub" -> SUB;
            case "mul" -> MUL;
            case "div" -> DIV;
            case "mod" -> MOD;
            case "and" -> AND;
            case "or" -> OR;
            case "xor" -> XOR;
            case "not" -> NOT;
            case "neg" -> NEG;
            case "shl" -> SHL;
            case "shr" -> SHR;
            case "ushr" -> USHR;
            case "inc" -> INC;
            case "dec" -> DEC;
            case "add_double" -> ADD_DOUBLE;
            case "sub_double" -> SUB_DOUBLE;
            case "mul_double" -> MUL_DOUBLE;
            case "div_double" -> DIV_DOUBLE;
            case "mod_double" -> MOD_DOUBLE;
            case "add_float" -> ADD_FLOAT;
            case "sub_float" -> SUB_FLOAT;
            case "mul_float" -> MUL_FLOAT;
            case "div_float" -> DIV_FLOAT;
            case "mod_float" -> MOD_FLOAT;
            case "atomic_add" -> ATOMIC_ADD;
            case "atomic_sub" -> ATOMIC_SUB;
            case "atomic_mul" -> ATOMIC_MUL;
            case "atomic_div" -> ATOMIC_DIV;
            case "atomic_mod" -> ATOMIC_MOD;
            case "atomic_and" -> ATOMIC_AND;
            case "atomic_or" -> ATOMIC_OR;
            case "atomic_xor" -> ATOMIC_XOR;
            case "atomic_not" -> ATOMIC_NOT;
            case "atomic_neg" -> ATOMIC_NEG;
            case "atomic_shl" -> ATOMIC_SHL;
            case "atomic_shr" -> ATOMIC_SHR;
            case "atomic_ushr" -> ATOMIC_USHR;
            case "atomic_inc" -> ATOMIC_INC;
            case "atomic_dec" -> ATOMIC_DEC;
            case "atomic_add_double" -> ATOMIC_ADD_DOUBLE;
            case "atomic_sub_double" -> ATOMIC_SUB_DOUBLE;
            case "atomic_mul_double" -> ATOMIC_MUL_DOUBLE;
            case "atomic_div_double" -> ATOMIC_DIV_DOUBLE;
            case "atomic_mod_double" -> ATOMIC_MOD_DOUBLE;
            case "atomic_add_float" -> ATOMIC_ADD_FLOAT;
            case "atomic_sub_float" -> ATOMIC_SUB_FLOAT;
            case "atomic_mul_float" -> ATOMIC_MUL_FLOAT;
            case "atomic_div_float" -> ATOMIC_DIV_FLOAT;
            case "atomic_mod_float" -> ATOMIC_MOD_FLOAT;
            case "cas" -> CAS;
            case "invoke" -> INVOKE;
            case "invoke_immediate" -> INVOKE_IMMEDIATE;
            case "return" -> RETURN;
            case "get_result" -> GET_RESULT;
            case "set_result" -> SET_RESULT;
            case "long_to_byte" -> LONG_TO_BYTE;
            case "long_to_short" -> LONG_TO_SHORT;
            case "long_to_int" -> LONG_TO_INT;
            case "byte_to_long" -> BYTE_TO_LONG;
            case "short_to_long" -> SHORT_TO_LONG;
            case "int_to_long" -> INT_TO_LONG;
            case "long_to_double" -> LONG_TO_DOUBLE;
            case "double_to_long" -> DOUBLE_TO_LONG;
            case "double_to_float" -> DOUBLE_TO_FLOAT;
            case "float_to_double" -> FLOAT_TO_DOUBLE;
            case "open" -> OPEN;
            case "close" -> CLOSE;
            case "read" -> READ;
            case "write" -> WRITE;
            case "create_frame" -> CREATE_FRAME;
            case "destroy_frame" -> DESTROY_FRAME;
            case "exit" -> EXIT;
            case "exit_immediate" -> EXIT_IMMEDIATE;
            default -> throw new IllegalArgumentException("Unknown instruction code: " + code);
        };
    }

    public static boolean isJump(byte code) {
        return code >= JUMP && code <= JUGE;
    }

    public static boolean isConditionalJump(byte code) {
        return code >= JE && code <= JUGE;
    }

    public static boolean isUnconditionalJump(byte code) {
        return code == JUMP || code == JUMP_IMMEDIATE;
    }

    public static boolean isArithmetic(byte code) {
        return code >= ADD && code <= DEC;
    }
}
